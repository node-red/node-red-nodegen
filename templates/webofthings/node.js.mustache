module.exports = function (RED) {
    "use strict";
    const request = require("request");
    const url = require('url');
    const HttpsProxyAgent = require('https-proxy-agent');
    const WebSocket = require('ws');
    const urltemplate = require('url-template');
    const Ajv = require('ajv');

    function extractTemplate(href, context={}) {
        return urltemplate.parse(href).expand(context);
    }

    function getResType(form) {
        if (form) {
            if (form.response && form.response.contentType) {
                return form.response.contentType;
            } else if (form.contentType) {
                return form.contentType;
            }
        }
        return "application/json";
    }

    function bindingWebSocket(node, form, options={}) {
        let ws;
        let reconnectTimeout;
        let needReconnect = false;
        const setupWsClient = () => {
            let wsoptions = {};
            if (process.env.http_proxy) {
                const agoptions = url.parse(process.env.http_proxy);
                const agent = new HttpsProxyAgent(agoptions);
                wsoptions = {agent: agent};
            }
            if (options.hasOwnProperty("auth") && 
                (options.auth.hasOwnProperty("user") || options.auth.hasOwnProperty("bearer"))) {
                wsoptions.auth = options.auth;
            }
            node.status({fill:"yellow",shape:"dot",text:"WS Connecting..."});
            needReconnect = true;
            const href = extractTemplate(form.href,options.urivars);
            ws = new WebSocket(href, wsoptions);
            node.trace(`Connecting websocket: ${form.href}`);

            ws.on('open', () => {
                node.status({fill:"green",shape:"dot",text:"WS Connected"});
                node.trace('websocket opened.');
            });
            ws.on('close', (code, reason) => {
                node.status({});
                node.trace(`websocket closed (code=${code}, reason=${reason})`); 
                if (needReconnect) {
                    node.status({fill:"orange",shape:"dot",text:`WS Reconnecting...`});
                    reconnectTimeout = setTimeout(setupWsClient, 5000);
                }
            });
            ws.on('error', (error) => {
                node.status({fill:"red",shape:"dot",text:`WS Error: ${error}`});
                node.warn(`websocket error: ${error}`);
            });
            ws.on('message', (data) => {
                node.status({fill:"green",shape:"dot",text:"WS OK"});
                const msg = {};
                if (getResType(form) === "application/json") {
                    try {
                        msg.payload = JSON.parse(data);
                    } catch(e) {
                        msg.payload = data;
                    }
                } else {
                    msg.payload = data;
                }
                if (options.outschema) {
                    const ajv = new Ajv({allErrors: true});
                    if (!ajv.validate(options.outschema, msg.payload)) {
                        node.warn(`ouput schema validation error: ${ajv.errorsText()}`, msg);
                    }
                }     
                node.send(msg)
            });
        }
        setupWsClient();
        node.on('close', () => {
            node.trace('Close node');
            clearTimeout(reconnectTimeout);
            needReconnect = false;
            try {
                ws.close();
            } catch (err) {

            }
            node.status({});
        });
    }

    function bindingLongPoll(node, form, options={}) {
        let reqObj;
        let needReconnect = false;
        let reconnectTimeout;
        const setupLPClient = () => { 
            const reqoptions = {};
            reqoptions.uri = extractTemplate(form.href, options.urivars);
            reqoptions.rejectUnauthorized = false;
            // reqoptions.timeout = 60000; 
            if (options && options.auth && (options.auth.user || options.auth.bearer)) {
                reqoptions.auth = options.auth;
            }
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "GET";
            node.trace(`LongPoll Request options: ${JSON.stringify(reqoptions)}`);
            needReconnect = true;
            reqObj = request(reqoptions, (err, res, body) => {
                if (err) {
                    const msg = {};
                    msg.payload = `${err.toString()}: ${reqoptions.uri}`;
                    msg.statusCode = err.code;
                    node.status({fill:"yellow",shape:"dot",text:"Polling error"});
                    node.send(msg);
                    if (needReconnect) {
                        reconnectTimeout = setTimeout(setupLPClient, 5000);
                    }
                } else {
                    const msg = {};
                    node.status({fill:"green",shape:"dot",text:"OK"});
                    msg.statusCode = res.statusCode;
                    msg.headers = res.headers;
                    msg.responseUrl = res.request.uri.href;
                    if (getResType(form) === "application/json") {
                        try {
                            msg.payload = JSON.parse(body);
                        } catch(e) {
                            msg.payload = body;
                        }
                    } else {
                        msg.payload = body;
                    }
                    // TODO: validation of return value
                    if (options.outschema) {
                        const ajv = new Ajv();
                        if (!ajv.validate(options.outschema, msg.payload)) {
                            node.warn(`ouput schema validation error: ${ajv.errorsText()}`, msg);
                        }
                    }     
                    node.send(msg);
                    if (needReconnect) {
                        reconnectTimeout = setTimeout(setupLPClient, 5000);
                    }
                }
            });
            node.status({fill:"green",shape:"dot",text:"Connecting..."});
        }
        setupLPClient();
        node.on("close", () => {
            node.status({});
            needReconnect = false;
            clearTimeout(reconnectTimeout);
            if (reqObj) {
                reqObj.abort();
            } 
        });
    }

    function bindingHttp(node, form, options={}) { // options.interaction, options.auth, options.reqbody, options.msg
        const msg = options.msg || {};
        const reqoptions = {}; 
        reqoptions.uri = extractTemplate(form.href, options.urivars);
        reqoptions.rejectUnauthorized = false;
        if (options.hasOwnProperty("auth") && 
            (options.auth.hasOwnProperty("user") || options.auth.hasOwnProperty("bearer"))) {
            reqoptions.auth = options.auth;
        }
        if (options.interaction === "property-read") {
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "GET";
        } else if (options.interaction === "property-write") {
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "PUT";
            switch (reqoptions.method) {
                case "GET":
                    break;
                case "POST":
                case "PUT":
                    reqoptions.json = form.contentType === "application/json";
                    reqoptions.body = options.reqbody;
                    reqoptions.headers = {'Content-Type': form.contentType};
                    break;
            }
        } else { // assume "action"
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "POST";
            switch (reqoptions.method) {
                case "GET":
                    break;
                case "POST":
                case "PUT":
                    reqoptions.json = form.contentType === "application/json";
                    reqoptions.body = options.reqbody;
                    reqoptions.headers = {'Content-Type': form.contentType};
                    break;
            }
        }
        node.trace(`HTTP request options: ${JSON.stringify(reqoptions)}`);
        request(reqoptions, (err, res, body) => {
            if (err) {
                node.log(`Error: ${err.toString()}`);
                msg.payload = `${err.toString()}: ${reqoptions.uri}`;
                msg.statusCode = err.code;
                node.send(msg); 
            } else {
                msg.statusCode = res.statusCode;
                msg.headers = res.headers;
                msg.responseUrl = res.request.uri.href;
                if (getResType(form) === "application/json") {
                    try {
                        msg.payload = JSON.parse(body);
                    } catch(e) {
                        msg.payload = body;
                    }
                } else {
                    msg.payload = body;
                }
                // TODO: validation of return value
                if (options.outschema) {
                    const ajv = new Ajv({allErrors: true});
                    if (!ajv.validate(options.outschema, msg.payload)) {
                        node.warn(`ouput schema validation error: ${ajv.errorsText()}`, msg);
                    }
                }    
                node.send(msg); 
            }
        });
    }

    function makeauth(td, form, username, password, token) {
        const scheme = td.securityDefinitions[form.security].scheme;
        const auth = {};
        switch (scheme) {
            case "basic":
                auth.user = username;
                auth.pass = password;
                auth.sendImmediately = true;
                break;
            case "digest":
                auth.user = username;
                auth.pass = password;
                auth.sendImmediately = false;
                break;
            case "bearer":
                auth.bearer = token;
                break;
        }
        return auth;
    }

    function Node(config) {
        RED.nodes.createNode(this, config);
        const node = this;
        node.interactiontype = config.interactiontype;
        node.propname = config.propname;
        node.proptype = config.proptype;
        node.actname = config.actname;
        node.evname = config.evname;
        node.formindex = config.formindex;
        node.status({});
        node.debug(`node config: ${JSON.stringify(node)}`);
        const username = node.credentials.username;
        const password = node.credentials.password;
        const token = node.credentials.token;
     
        node.td = {{{tdstr}}};
        const normTd = {{{normtd}}};
        if (node.interactiontype === "property") {
            if (node.proptype === "read") {
                node.on("input", (msg) => {
                    const prop = normTd.properties[node.propname];
                    const form = prop.forms[node.formindex];// formSelection("property-read", prop.forms);
                    const auth = makeauth(normTd, form, username, password, token);
                    const urivars = prop.hasOwnProperty("uriVariables") ? msg.payload : {};
                    if (prop.uriVariables) {
                        const ajv = new Ajv({allErrors: true});
                        if (!ajv.validate(prop.uriVariables, urlvars)) {
                            node.warn(`input schema validation error: ${ajv.errorsText()}`, msg);
                        }
                    }
                    bindingHttp(node, form, {interaction:"property-read", auth, msg, urivars, outschema: prop});
                });
            } else if (node.proptype === "write") {
                node.on("input", (msg) => {
                    const prop = normTd.properties[node.propname];
                    const form = prop.forms[node.formindex];// formSelection("property-write", prop.forms);
                    const auth = makeauth(normTd, form, username, password, token);
                    const ajv = new Ajv({allErrors: true});
                    if (!ajv.validate(prop, msg.payload)) {
                        node.warn(`input schema validation error: ${ajv.errorsText()}`, msg);
                    }
                    // URI template is not supported, because 'write' doesn't use GET method.
                    bindingHttp(node, form, {interaction: "property-write", auth, msg, reqbody: msg.payload});    
                });
            } else if (node.proptype === "observe") {
                const prop = normTd.properties[node.propname];
                const form = prop.forms[node.formindex];// formSelection("property-observe", prop.forms);
                const auth = makeauth(normTd, form, username, password, token);
                const urivars = prop.hasOwnProperty("uriVariables") ? msg.payload : {};
                if (prop.uriVariables) {
                    const ajv = new Ajv({allErrors: true});
                    if (!ajv.validate(prop.uriVariables, urivars)) {
                        node.warn(`input schema validation error: ${ajv.errorsText()}`, msg);
                    }
                }
                if (form.href.match(/^wss?:/)) { // websocket
                    bindingWebSocket(node, form, {auth, urivars, outschema: prop});
                } else { // long polling
                    bindingLongPoll(node, form, {auth, urivars, outschema: prop});
                }               
            }
        } else if (node.interactiontype === "action") {
            node.on("input", (msg) => {
                const act = normTd.actions[node.actname];
                const form = act.forms[node.formindex];// formSelection("action", act.forms);
                const auth = makeauth(normTd, form, username, password, token);
                const urivars = act.hasOwnProperty("uriVariables") ? msg.payload : {};
                if (act.uriVariables) {
                    const ajv = new Ajv({allErrors: true});
                    if (!ajv.validate(act.uriVariables, urivars)) {
                        node.warn(`input schema validation error: ${ajv.errorsText()}`, msg);
                    }
                }
                if (act.input) {
                    const ajv = new Ajv({allErrors: true});
                    if (!ajv.validate(act.input, msg.payload)) {
                        node.warn(`input schema validation error: ${ajv.errorsText()}`, msg);
                    }
                }
                bindingHttp(node, form, {interaction: "action", auth, msg, urivars, reqbody:msg.payload});                
            });
        } else if (node.interactiontype === "event") {
            const ev = normTd.events[node.evname];
            const form = ev.forms[node.formindex];// formSelection("event", ev.forms);
            const auth = makeauth(normTd, form, username, password, token);
            const urivars = ev.hasOwnProperty("uriVariables") ? msg.payload : {};
            if (ev.uriVariables) {
                const ajv = new Ajv({allErrors: true});
                if (!ajv.validate(ev.uriVariables, urivars)) {
                    node.warn(`input schema validation error: ${ajv.errorsText()}`, msg);
                }
            }
            if (form.href.match(/^wss?:/)) { // websocket
                bindingWebSocket(node, form, {auth, urivars});
            } else { // long polling
                bindingLongPoll(node, form, {auth, urivars});
            }               
        }
    }
    
    RED.nodes.registerType("{{&nodeName}}", Node, {
        credentials: {
            token: {type:"password"},
            username: {type:"text"},
            password: {type:"password"}
        }
    });
};